# 深浅拷贝
- Object.assign() 开始
    浅拷贝 简单，功能强大
- es6 新特性，让我们快速获取源对象的属性
- Object.assign() 方法用于将一个或多个源对象的所有**可枚举**属性复制到目标对象，并返回修改后的目标对象，常用于对象的浅拷贝或属性合并。
    - 如果有冲突的属性，后面的会覆盖掉前面的
    - 源对象可以不传，或者是简单数据类型会忽略，但是目标对象不能为空

- 返回的是新对象？
    - 不是新对象，是目标对象
- 不支持深拷贝
    - 不安全
    - 如果源对象的属性值是引用类型，那么目标对象的属性值会指向源对象的属性值的内存地址，改变目标对象的属性值，会影响源对象的属性值
- 如何实现深拷贝
    管他有多深，都能一直拷贝过来，不会影响源对象
- 在项目中的具体使用：合并参数

- 面试官的想法
    - 深拷贝、浅拷贝是必考内容
    - 以Object.assign() 开场
        - 表演时间 面试是当面展示自己
        API 细节 -> 业务场景（在开发之中怎么用的） -> 赋值+引用浅拷贝->底层原理

        JSON.parse(JSON.stringify()) 最简单的方法
        不会拷贝函数（不知道怎么序列化），symbol也不会拷贝，undefined 会被忽略,循环引用
        勾引对方考察手写深拷贝
        - 赋值和引用式的概念
            简单数据类型和复杂数据类型 内存分配不一样
- 如何拷贝，看业务
    - 如果是简单数据类型，`=`就可以
    - 如果是浅的对象或者数组
        Object.assign()
        Array.prototype.slice
        Array.prototype.concat
    - 否则使用 
        - 简单深拷贝 Object.parse(Object.stringfy)
        JSON.stringify()序列化规则
        undefined,function,Symbol不是合法的JSON值
        - 复杂深拷贝：函数的拷贝，Symbol的拷贝 手写实现
    - 手写实现高级深拷贝
        - JSON.stringify() 没办法拷贝的
        - 拷贝，简单， 遍历， 复制
        - 深度， 递归









