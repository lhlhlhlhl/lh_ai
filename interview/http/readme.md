# http 各个版本的特性

- OSI 七层模型
- 基于TCP/IP 四层模型
- 三次握手/四次握手
- http/https
- 浏览器缓存
- http 各个版本的特性
- TCP 和 UDP

## 版本特性
- 讲清楚有哪些版本 五个
    HTTP 0.9 
    Hyper Text Transfer Protocol(超文本传输协议)
    最早的版本，只支持GET请求，响应只有HTML文本，没有**header**
    只能传输简单网页，连图片、css、js都不能传输
    image/jpg text/css text/js 这些数据类型要放在请求头

    HTTP 1.0
    引入了请求头 header，能传输多种类型数据
    图片等
    虽然有cookie，但是http仍然是无状态的
    **每次请求都要重新建立TCP连接**
        开销浪费 同域名下的资源，一条路
        早期用户并不多
        http 基于请求响应的简单协议 TCP链接 断开

    HTTP 1.1
    - 用户太多了，一定要解决TCP链接每次都重新建立的问题
    - 推出了长链接：
        - Connection:keep-alive（滑滑梯）
        一个TCP可以处理多个请求，浏览器通过一个TCP链接连续请求
        页面、图片、脚本等多个资源，服务器处理不会立刻断开，而是保持链接，后续请求无需重新建立链接，节省事件和性能开销，提高加速速度

        - 管道化 pipeling
        允许同时发送多个请求，响应必须按顺序返回

        - 数据分块传输 chunk(没有编号)

        你用支持管道化的浏览器，依次发送 获取首页、图片1、图片2、无需等待前一个响应。但服务器必须按顺序返回

        TCP可靠的传输，一个通信的多个数据包，按顺序、全部到达浏览器
        没有能真正的并发，TCP 安全 响应时还是顺序传输
        队头阻塞，如果排在前面的资源传输慢，后面的就没有办法传输

        - 怎么优化网页加载速度，在通信这块？
            - 路由懒加载，分包
                App.jsx 不同的文件
                Login.jsx
            - http 优化，图片懒加载
                js/css/img 过多，合并文件
                同一个域名请求并发的上限是6个
            - base 64 图片 html/css文件里，减少了请求
            - 图标字体库
            - 开启压缩
            - 使用多个域名



    HTTP 2.0
        - 并发 多路复用
            一个TCP链接上并发多个请求，不再对头阻塞
            多路复用把数据拆成帧交错传输，请求和响应可以并行独立
            不会相互阻塞
        - 二进制数据帧
            所有请求和响应都拆成小数据帧，通过一个链接并发传输，每个帧带有编号
            指定是哪个文件，客户端和服务器端可以根据编号重组
            无需排队，谁先准备好谁就出发，解决了对头阻塞问题

        - 头部压缩 减少重复header 传输

        - 服务器端推送 server push
            服务器端可主动推送资源  首页GET返回很快，但首屏还依赖app.css app.js等，为了减少首轮返回，服务器会主动push这些资源
    HTTP 3.0
        基于QUIC协议，改用UDP代替TCP 作为传输层
页面快速显示