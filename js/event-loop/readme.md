# event loop
时间循环机制  JS执行机制

- js 单线程
同一时刻只能做一件事
同步任务尽快执行完，尽快渲染页面（重绘重排），响应用户的交互
耗时性的任务
    - setTimeout/setIntervsal
    - fetch/ajax
    - envetListener

- script 脚本
  一个宏任务

- 微任务有哪些？
  紧急的，优先的，同步任务执行完之后的一个补充
  - Promise.then
  - MutationObserver（为什么要把它设计为微任务？）
    dom的改变 在页面渲染前执行 在页面渲染前拿到DOM 有啥改变
  - queueMicrotask  微任务队列
  - process.nextTick()
  - requestAnimationFrame 
event loop 为什么要设计单线程？ 从浏览器的多线程说起 浏览器多进程架构
## 多进程和多线程
- CPU 轮循 一秒钟60帧，不能超过16ms
- 进程（负责汇报，管理）
  分配资源的最小单元
    内存（地址，物理） CPU计算的机会
    独立的进程ID 根据进程申请的内存地址和CPU计算的复杂性分配ID
    拿到进程ID 就拿到了CPU计算的机会
    程序运行以进程为单位
    - 主进程 （进程之间的协调，统一向CPU申请执行机会）
      管理子进程 每个进程各司其职 可以并发 并行  父子关系
      **进程间的通信**
    - 主线程
      执行JS代码
- 线程
  干活的
- 进程间的通信 即使是两个独立的应用程序 也可以通信
  两个独立进程间的通信开销很大
  父子进程之间就好点——这就是为什么需要主进程，主进程不负责渲染

- chrome浏览器是多进程架构
  - 浏览器主进程 进程之间的协调，统一向CPU申请执行机会
  - 一个tab（页面）就是一个渲染进程
    多线程
    几个tab几个进程（为了确保进程的安全，快速，一个页面crash了，别的不受影响）
  - 进程要工作就会启动一个主线程(执行的最小单元) 主角
    JS 单线程 （同时是执行一个任务，JS只会在渲染进程的主线程里面执行，渲染进程是多线程的架构）
    目的：
    - 简单
    - 安全 编程模型的需要 DOM编程模型 不能产生线程的争抢（为什么JS要放在最底下，为什么执行完宏任务之后才渲染？）
- 在渲染进程中的多线程 
 - setTimeout离开主线程，会被专属的定时器线程拿走
   到时间了，callback(回调函数) 放入宏任务队列
   放到event loop中 放到队列中 排队
   为什么在渲染进程的主线程里面要负责页面的渲染：
   为什么setTimeout 不准？微任务太多了，只有执行栈空了，才会执行宏任务
   宏任务，微任务的回调函数什么时候才是真正执行了？
   执行一定在主线程，从任务队列中放入执行栈的时候
   宏任务，微任务 队列
 - addEventListener 没有独立的线程
   跟DOM相关 不需要独立 之间放到宏任务队列里面
 - fetch/ajax 专属的下载线程 
调用栈：主线程中维护的JS执行的数据结构（什么叫异步任务？申明异步任务的是同步任务）
时间队列：主线程中放置宏任务和微任务的队列的数据结构
- 渲染进程的主线程
  - 解析HTML->构建DOM树
  - 解析CSS->构建CSSOM树
  - 合并DOM树和CSSOM树->构建Render树（渲染树）
  - 布局Render树->layout树（布局树）
  - 绘制layout树->图层（图层）
  - 合并图层
  - v8引擎 JS的执行
  - 独立的绘制线程

- 事件队列？
  - 定时器到点了
  - onreadystatechange  4
  - 宏任务队列
  - 页面渲染 由独立的绘制线程（页面的绘制）完成 不属于宏任务和微任务
  - 微任务队列

为什么渲染放到微任务之后，宏任务之前？
- JS和渲染时互斥的
- JS批量化整理出来页面到哪里需要改变，然后交给绘制线程

只要进入了队列里面都是可以执行的，在其他线程里面就会判断是否可以正常执行